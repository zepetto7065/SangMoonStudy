############################################################################### SQL 중심적인 개발의 문제점 ###########################################

JPA와 모던 자바 데이터 저장 기술

SQL 중심적인 개발의 문제점
SQL ? 데이터베이스는 SQL만 알아들을 수 있다. 
SQL 중심적 개발의 문제점
1. 무한반복, 지루한 코드
가령, 멤버테이블에 전화번호 라는 컬럼 추가시 모든 쿼리에 전부 전화번호를 추가해야한다
-> 의존적인 개발을 피하기 어렵다

2. 패러다임의 불일치
객체를 중심으로 생각해보면, 객체를 영구 보관하는 다양한 보관소가 무엇일까

객체와 관계형 데이터베이스의 차이
1. 상속
DB -> x ( 그나마 유사한 슈퍼/서브 타입 ), 객체 -> 상속관계
상속관계의 DB는 join해서 가져오는 방식을 여러번 해야한다. -> 번잡하다
DB가 아닌 Java 컬렉션에 저장을 한다면? 그냥 넣고 빼기만 하면 된다. 가령 list.get(a) 

2. 연관관계
DB -> join , 객체 -> 참조
객체는 참조를 사용, 테이블은 외래키를 사용
객체는 한방향, 테이블은 양방향 -> 차이가 있다
객체를 테이블에 맞추어서 모델링 

엔티티에 대한 신뢰 문제 
-> 코드를 까보지 않는 이상 신뢰하기 힘들다

그렇다고 모든 객체를 미리 로딩할 수는 없다

계층형 아키텍처 진정한 의미의 계층 분할이 어렵다

비교하기 자바 컬렉션에서 조회
-> sql 에서 객체를 다를떄와 달리 같다.

객체를 자바 컬렉션에 저장하듯이 DB에 저장할 수 없을까? -> JPA

############################################################################### JPA 소개 0###########################################
JPA -> Java Persistence API
자바 진영의 ORM 기술 표준

ORM -> Object-relational maping (객체 관계 매칭)
객체는 객체대로 , 관계형 DB는 DB대로 설계후 ORM 이 매핑을 해준다. 

JPA 안에 JDBC API 와 JAVA 어플리케이션 사이에서 작동 
객체가 넘어오면 객체를 분석 -> Entity 분석, 쿼리 생성 -> DB에 반환
(* 중요한건 패러다임의 불일치 해결)

EJB (엔티티 빈 - 속도느리고 , 성능이 잘 안나온다.) -> 하이버네이트(오픈소스) -> JPA(자바 표준 현재 2.2로 대부분 개발)

#왜 사용하는가?
1. 생산성
저장 jpa.persit(member)
조회 jpa.find(memberId)
삭제 jpa.remove(member)
수정 member.setName("변경할 이름) -> 자바 컬렉션처럼 꺼냈다 뺐다하는 개념이 JPA 

2. JPA 패러다임의 불일치 해결
상속  - join을 알아서 해준다
연관관계 - 마치 자바 컬렉션에 있듯 객체 안(member)에 있는 객체(Team)을 가져올 수 있다.
계층 - 자유롭게 객체 그래프 탐색
비교 - == 비교시 같다고 나온다. 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장

3. 성능 최적화 기능
- 1차 캐시와 동일성보장 (identity) 
- 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
jpa에서는 옵션하나로 한방에(?) 보내준다. JDBC BATCH SQL을 사용하면 지저분해진다.
- 지연로딩 (Lazy Loading)
이것도 옵션하나로 껐다 킬수 있다 
지연로딩 : 객체가 실제 사용될 때 로딩
즉시로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회

ORM은 객체와 RDB 두 기둥위에 있는 기술


