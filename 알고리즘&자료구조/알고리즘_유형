알고리즘 정리 
# 그리디 (Greedy)
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법 
- 사전에 외우지 않아도 풀 수 있는 유형
- 대표 문제 > 거스름돈 문제

# 구현
- 아이디어를 코드로 바꾸는 유형
- 상하좌우 문제 유형 
- 프로그래밍 문법이나 라이브러리 사용 경험 부족시, 불리

# DFS / BFS
# DFS (Depth First Search)
- 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

# DFS의 구조적 동작 과정
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리, 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번 과정을 수행할 수 없을 떄까지 반복

# BFS (Breath First Search)
- 가까운 노드부터 탐색하는 '너비 우선 탐색'

# BFS의 동작 과정
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리한다.
3. 2번 과정을 수행할 수 없을 때까지 반복

# 정렬
- 선택 정렬 : 가장 원시적인 방법, 가장 작은 데이터를 선텍해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두번쨰 데이터와 바꾸는 과정 반복
- 선택 정렬의 시간 복잡도  O(N^2)

- 삽입 정렬 : 직관적인 이해가 쉽다. 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입
- 삽입 정렬의 시간 복잡도  O(N^2)

- 퀵 정렬 : '피벗'이 사용됨. 기준 데이터 ( 피벗 )을 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다.
- 퀵 정렬의 시간 복잡도 O(NlogN)

- 계수 정렬 : 특정한 조건이 부합할 떄만 사용할 수 있지만 매우 빠른 정렬 알고리즘
- 일반적으로 가장 큰 데이터와 가장 작은 데이터 차이가 1,000,000을 넘지 않을 떄 효과적으로 사용할 수 있다.
- 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야함
- 계수 정렬의 시간 복잡도 O(N+K)

# 이진 탐색
- 순차 탐색 : 리스트 안에 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법
- 이진 탐색 :  찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교

# 다이나믹 프로그래밍
- 한번 계산한 연산은 다시 하지않는다.(ex 피보나치 수열)
- 다이나믹 프로그래밍 조건 
-> 1. 큰 문제를 작은 문제로 나눌 수 있다.
 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

# 메모이제이션 - 값을 저장하는 방법 (캐싱)
# 탑다운
# 보텀업

#최단경로
# 다익스트라 알고리즘

# 해쉬(Hash) 
- 컴퓨팅에서 키를 값에 매핑할 수 있는 구조